# 技术文档：`response_parser.py` 终极防御性重构

**日期:** 2025-10-11
**作者:** Jules

## 1. 背景与问题

项目的核心翻译流程严重依赖于上游LLM返回的JSON格式数据。然而，观测表明，LLM的输出极不稳定，频繁返回包含各类语法错误的JSON响应（例如，被Markdown代码块包裹、缺失逗号、包含未转义的内部引号、尾随无关文本、甚至重复的JSON块等）。

这些被“数据投毒”的响应直接导致了 `json.loads()` 解析失败，频繁中断核心翻译流程，使得已有的简单修复逻辑难以为继。为了“一次性”解决所有已知的解析问题，并确保系统的长期稳定运行，我们决定对 `scripts/utils/response_parser.py` 进行一次彻底的、以终极防御为目标的重构。

## 2. 设计哲学：“三道防线”与“永不崩溃”

本次重构的核心设计思想是建立一个多层、纵深的防御体系，并遵循一个最高原则：“**永不因解析失败而崩溃**”。

### 第一道防线：净化器 (The Purifier)

- **目标**: 清除所有外部污染，从原始响应中强行提取出核心的、有潜在价值的JSON数据块。
- **实现**: 使用贪婪正则表达式 `re.search(r"\[.*\]", response_text, re.DOTALL)`，从原始响应中提取第一个 `[` 和最后一个 `]` 之间的所有内容。
- **优势**: 这种方法能有效剥离` ```json `之类的Markdown包装、以及LLM在JSON前后添加的任何“读后感”或无关文本。同时，因为它只匹配第一个 `[` 和最后一个 `]`，所以也能防御LLM返回重复JSON块的攻击。

### 第二道防线：外科医生 (The Surgeon)

- **目标**: 对净化后的核心 `[...]` 字符串，进行一系列精细的、序列化的内部修复手术。
- **实现**: 在 `_run_repair_surgeries` 私有函数中，按特定顺序执行修复：
    1.  **修复已知问题字符串**: 将已知的、未被引号包裹的 `WARNING: ...` 字符串，用双引号包裹起来，使其成为合法的JSON字符串成员。
    2.  **修复缺失的逗号**: **(关键顺序)** 首先执行这项简单、明确的修复。使用 `re.sub(r'(?<!\\)"\s*(?<!\\)"', '","', ...)` 来查找所有被空格（或没有空格）隔开的连续字符串，并在它们之间插入逗号。将此步骤置于引号修复之前，可以避免更复杂的修复逻辑对这种简单模式造成干扰。
    3.  **修复内部未转义引号**: 在基本结构（逗号）被修复后，再执行这个复杂的手术。我们采用了一个基于**状态机**的迭代方法，而不是复杂的正则表达式，来智能地判断一个双引号是字符串的边界还是需要被转义的内部内容。它通过向前“窥视”引号后面的字符（是否为逗号、方括号等）来做出判断，确保了修复的精确性，避免了“误伤”。

### 第三道防线：审判者 (The Judge)

- **目标**: 对经过两层处理后的字符串进行最终的解析审判。
- **实现**: 将经过“外科手术”的字符串放入 `try...except json.JSONDecodeError` 块中。如果 `json.loads()` 成功，则返回列表。如果仍然失败，则触发最终防御预案。

### 最终防御预案：永不崩溃 (The Ultimate Fallback)

- **目标**: 在任何灾难性解析失败的情况下，保证程序流程不中断，且下游数据结构完整。
- **实现**: 当“净化器”或“审判者”失败时：
    1.  调用 `logging.critical()` 记录一条极其严重的错误日志，并将原始响应、净化后的文本、修复后的文本**全部**保存到`logs/critical_parse_failure_...`文件中，为未来的算法改进提供宝贵线索。
    2.  **返回 `original_input_list`**。这是设计的核心，确保即使翻译完全失败，我们也能生成一个包含原文的本地化文件，保证玩家的基础游戏体验，而不是让整个流程因为一个批次的失败而崩溃。

## 3. 函数签名变更与调用点重构

为了支持“最终防御预案”，核心函数签名被修改为：

`parse_json_from_response(response_text: str, original_input_list: list[str]) -> list[str]`

所有之前调用旧解析器的地方 (`scripts/core/base_handler.py` 和 `scripts/core/gemini_cli_handler.py`) 都已完成重构，以适应新的函数签名。同时，由于新的解析器永不抛出 `ParsingFailedAfterRepairError` 异常，相关的异常捕获逻辑也已被移除。

## 4. 极限压力测试

我们创建了全新的测试文件 `tests/utils/test_response_parser.py`，它包含了覆盖所有已知“投毒”手段的极限压力测试用例。采用测试驱动开发（TDD）的方法，确保了重构后的解析器在以下所有场景中都能正确工作（要么成功解析，要么安全回退）：
- 完美合法的JSON
- Markdown代码块包裹
- 尾随无关文本
- 缺失逗号（有/无空格）
- 字符串内部包含未转义的双引号
- 未被包裹的WARNING信息
- 无法修复的结构性损坏（括号不匹配）
- 完全不包含JSON数组
- 上述所有问题的混合攻击

所有测试现已全部通过，证明了新解析器的健壮性。
