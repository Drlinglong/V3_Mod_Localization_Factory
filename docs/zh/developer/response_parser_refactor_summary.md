# 技术文档：`response_parser.py` 终极防御性重构

**日期:** 2025-10-12 (更新)
**作者:** Jules

## 1. 背景与问题

项目的核心翻译流程严重依赖于上游LLM返回的JSON格式数据。然而，观测表明，LLM的输出极不稳定，频繁返回包含各类语法错误的JSON响应。这些响应的格式多种多样，包括但不限于：

- 被Markdown代码块包裹。
- 缺失逗号、包含未转义的内部引号、尾随无关文本。
- **(新发现)** 返回一个嵌套的JSON对象，其中真正的翻译结果（JSON数组字符串）被包裹在顶层的一个键（例如 `"response"`) 中，如 `{"response": "[...]"}`。

这些被“数据投毒”的响应直接导致了 `json.loads()` 解析失败，频繁中断核心翻译流程。为了系统性地解决所有已知和潜在的解析问题，并确保系统的长期稳定运行，我们决定对 `scripts/utils/response_parser.py` 进行一次彻底的、以终极防御为目标的重构。

## 2. 设计哲学：“四道防线”与“永不崩溃”

本次重构的核心设计思想是建立一个多层、纵深的防御体系，并遵循一个最高原则：“**永不因解析失败而崩溃**”。我们将防御体系从三层升级为四层。

### **第0道防线：智能预检 (The Triage)**

- **目标**: 在解析开始前，对输入字符串进行智能“分诊”，判断其**核心类型**：它是一个需要严格验证的JSON对象，还是一个需要宽松处理的脏字符串？
- **实现**:
    1.  尝试将完整的输入字符串 `response_text` 作为JSON进行解析 (`json.loads`)。
    2.  如果成功解析为一个**字典 (dict)**，则激活**严格模式**：
        - **必须**包含一个名为 `"response"` 的键。
        - 该键的值**必须**是一个字符串。
        - 如果任一条件不满足，则判定为无效的嵌套结构，**立即失败并返回原始输入**，不再进行后续处理。这可以防止意外解析混入响应中的调试信息或错误对象。
        - 如果验证通过，则将 `"response"` 键的值作为新的目标字符串，交给后续防线处理。
    3.  如果输入字符串无法被解析为一个JSON对象（抛出 `json.JSONDecodeError`），则激活**宽松模式**：我们假定它是一个需要净化和修复的“脏字符串”，并将其**原样**交给后续防线处理。
- **优势**: 这一步将两种完全不同的输入（结构化对象 vs. 非结构化文本）清晰地分离开，并对结构化数据执行了更严格、更安全的验证，从根本上解决了 `gemini_cli` handler 的问题，并遵循了单一职责原则。

### 第一道防线：净化器 (The Purifier)

- **目标**: 清除所有外部污染，从经过“预检”的目标字符串中强行提取出核心的、有潜在价值的JSON数据块。
- **实现**: 使用**非贪婪**正则表达式 `re.search(r"\[.*?\]", ..., re.DOTALL)`，提取第一个 `[` 和**最近的** `]` 之间的所有内容。
- **优势**:
    - **非贪婪匹配**: 这是对旧版本的关键改进。它能正确处理外部JSON损坏，但内部JSON数组依然完整的情况，避免因贪婪匹配吞噬过多内容而导致解析失败。
    - 能有效剥离` ```json `之类的Markdown包装、以及LLM在JSON前后添加的任何无关文本。

#### 启发式修复 (Heuristic Repair)

- **目标**: 解决因“预检”步骤成功解包后，内部字符串中残留的转义引号问题 (例如, `[\"A\", \"B\"]`)。
- **实现**: 在“净化器”提取出 `purified_text` 之后，增加一个启发式判断：如果原始的、未经“净化器”处理的 `payload_to_process` 是以 `{` 开头的，则**强烈暗示**它是一个JSON对象，那么我们对提取出的 `purified_text` 执行一次 `replace('\\"', '"')` 操作来清理多余的转义。
- **优势**: 这种方法将修复操作限制在最可能需要它的上下文中，避免了全局替换可能导致的回归性bug（例如，破坏字符串中合法的 `\\"` 转义序列）。

### 第二道防线：外科医生 (The Surgeon)
- **目标**: 对净化和修复后的核心 `[...]` 字符串，进行一系列精细的、序列化的内部修复手术。
- **实现**: 在 `_run_repair_surgeries` 私有函数中，按特定顺序执行修复：
    1.  **修复已知问题字符串**
    2.  **修复缺失的逗号**
    3.  **修复内部未转义引号** (基于状态机)

### 第三道防线：审判者 (The Judge)
- **目标**: 对经过多层处理后的字符串进行最终的解析审判。
- **实现**: 将处理后的字符串放入 `try...except json.JSONDecodeError` 块中。

### 最终防御预案：永不崩溃 (The Ultimate Fallback)
- **目标**与**实现**保持不变：在任何不可恢复的失败情况下，记录详细日志，并**返回 `original_input_list`**，确保数据流的完整和程序的稳定。

## 3. 函数签名与调用点
函数签名 `parse_json_from_response(response_text: str, original_input_list: list[str]) -> list[str]` 保持不变。由于所有智能逻辑都已内聚到该函数内部，**所有API handler都无需任何修改**，自动获得了更强的鲁棒性。

## 4. 极限压力测试
`tests/utils/test_response_parser.py` 中的测试套件已大幅扩展，以验证新的四层防御体系。新增的测试用例覆盖了：
- **(新)** 成功的嵌套JSON解包 (`gemini_cli_style_success`)。
- **(新)** 外部JSON损坏但内部可被成功解析的场景 (`malformed_outer_json_fallback_success`)。
- **(新)** 严格模式下的失败场景，如缺少`response`键或`response`值类型错误 (`missing_response_key_fallback`, `wrong_payload_type_fallback`)。
- 所有旧有的“投毒”手段的测试用例。

所有测试现已全部通过，证明了新解析器架构的全面健壮性。
