"""
Core module for formatting Steam Workshop descriptions.
"""
import os
import requests
import datetime
from scripts.utils import logger
from scripts.config.prompts import STEAM_BBCODE_PROMPT_TEMPLATE
from scripts.app_settings import LANGUAGES
from scripts.core.glossary_manager import glossary_manager
from scripts.core.api_handler import get_handler


def get_workshop_item_details(item_id: str) -> str | None:
    """
    Fetches the description of a published file from the Steam Workshop.

    Args:
        item_id: The ID of the Steam Workshop item.

    Returns:
        The description of the item as a string, or None if an error occurs.
    """
    url = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/"
    payload = {'itemcount': 1, 'publishedfileids[0]': item_id}
    logger.info(f"Fetching details for Workshop item: {item_id}")

    try:
        response = requests.post(url, data=payload, timeout=15)
        response.raise_for_status()

        data = response.json()

        if (data.get('response') and
                data['response'].get('publishedfiledetails') and
                len(data['response']['publishedfiledetails']) > 0 and
                data['response']['publishedfiledetails'][0].get('result') == 1):

            description = data['response']['publishedfiledetails'][0].get('description', '')
            logger.success(f"Successfully fetched description for item {item_id}.")
            return description
        else:
            error_details = data.get('response', 'No response data')
            logger.error(f"Steam API returned an unsuccessful response for item {item_id}. Details: {error_details}")
            return None

    except requests.exceptions.RequestException as e:
        logger.error(f"An error occurred while fetching Steam Workshop details for item {item_id}: {e}")
        return None
    except KeyError as e:
        logger.error(f"Failed to parse Steam API response for item {item_id}. Missing key: {e}")
        return None


def format_description_with_ai(
    original_description: str,
    user_template: str,
    target_language: str,
    project_id: str,
    selected_provider: str,
    custom_language: str = ""
) -> str:
    """
    Integrates, enriches, and formats a workshop description using a glossary and an AI provider.

    Args:
        original_description: The original English description from Steam Workshop.
        user_template: User-provided template text.
        target_language: The target language code (e.g., 'zh', 'en').
        project_id: The ID of the project, used to determine which glossary to load.
        selected_provider: The key for the selected API provider.
        custom_language: The custom language name specified by the user, if any.

    Returns:
        A formatted string in Steam BBCode, generated by the AI.
    """
    logger.info(f"Formatting description for project '{project_id}' using '{selected_provider}'.")

    # --- 1. Load Glossary ---
    # The project_id is assumed to be the game_id for the glossary
    game_id = project_id
    if game_id:
        logger.info(f"Loading glossary for game: {game_id}")
        glossary_manager.load_game_glossary(game_id)
        # We don't need to check for existence, the manager handles it gracefully.
    else:
        logger.warning("No project_id provided, skipping glossary injection.")

    # --- 2. Prepare Text and Prompt ---
    language_name = ""
    if target_language == 'custom' and custom_language:
        language_name = custom_language
    else:
        lang_info = LANGUAGES.get(target_language)
        language_name = lang_info.get("name", target_language) if lang_info else target_language

    full_text_to_process = f"### User's Template ###\n{user_template}\n\n### Original Description ###\n{original_description}"

    # --- 3. Glossary Term Injection (Preprocessing) ---
    if game_id and glossary_manager.glossaries:
        logger.info("Injecting glossary terms into the text...")
        # This is a simplified injection, assuming a method exists.
        # A more sophisticated approach from the main translation workflow might be needed.
        injected_text, _ = glossary_manager.inject_glossary_terms(
            text_to_translate=full_text_to_process,
            source_lang_code='en', # Assume template is in English context
            target_lang_code=target_language
        )
        final_text = injected_text
        logger.success("Glossary injection complete.")
    else:
        final_text = full_text_to_process

    prompt = STEAM_BBCODE_PROMPT_TEMPLATE.format(
        target_language_name=language_name,
        raw_text=final_text
    )

    # --- 4. Call Selected AI Provider ---
    try:
        handler = get_handler(selected_provider)
        if not handler or not handler.client:
            logger.error(f"Failed to get a configured handler for '{selected_provider}'.")
            return f"[AI Formatting Skipped - Handler for '{selected_provider}' Not Configured]"

        logger.info(f"Sending combined text to '{selected_provider}' for formatting...")
        response = handler.get_response(prompt)
        logger.success(f"Successfully received formatted BBCode from '{selected_provider}'.")
        return response
    except Exception as e:
        logger.error(f"An error occurred during AI description formatting with '{selected_provider}': {e}")
        return f"[AI Formatting Failed with {selected_provider}: {e}]"


def archive_generated_description(project_id: str, bbcode_content: str, workshop_id: str) -> str | None:
    """
    Saves the generated BBCode content to a file.
    """
    try:
        project_dir = os.path.join("my_translation", project_id) if project_id else "generated_descriptions"
        archive_dir = os.path.join(project_dir, "generated_descriptions") if project_id else project_dir
        os.makedirs(archive_dir, exist_ok=True)

        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H%M%S")

        base_name = project_id if project_id else f"workshop_{workshop_id}"
        filename = f"{base_name}_{timestamp}.md"

        file_path = os.path.join(archive_dir, filename)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(bbcode_content)

        logger.success(f"Successfully archived generated description to: {file_path}")
        return file_path
    except IOError as e:
        logger.error(f"Failed to write archive file: {e}")
        return None
    except Exception as e:
        logger.error(f"An unexpected error occurred during archiving: {e}")
        return None
